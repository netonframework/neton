package neton.ksp

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import java.io.OutputStreamWriter

private data class ConfigEntry(val component: String, val order: Int, val clazz: KSClassDeclaration)

/**
 * 扫描 @NetonConfig(component, order) 并按 component 分组，生成 GeneratedNetonConfigRegistry。
 *
 * 模块模式（moduleId 存在）：不生成独立文件，将配置器注册代码写入 ModuleFragmentSink。
 * 兼容模式（moduleId 不存在）：生成 GeneratedNetonConfigRegistry 到 neton.core.generated。
 */
class NetonConfigProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger,
    private val options: Map<String, String> = emptyMap()
) : SymbolProcessor {

    private val moduleId: String? = options["neton.moduleId"]?.takeIf { it.isNotBlank() }
    private val netonConfigAnnotationName = "neton.core.config.NetonConfig"

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val symbols = resolver.getSymbolsWithAnnotation(netonConfigAnnotationName)
        val configClasses = symbols.filterIsInstance<KSClassDeclaration>().toList()

        val grouped = configClasses.mapNotNull { clazz ->
            val ann =
                clazz.annotations.firstOrNull { it.shortName.asString() == "NetonConfig" } ?: return@mapNotNull null
            val component =
                ann.arguments.find { it.name?.asString() == "component" }?.value as? String ?: return@mapNotNull null
            val order = ann.arguments.find { it.name?.asString() == "order" }?.value as? Int ?: 0
            ConfigEntry(component, order, clazz)
        }.groupBy({ it.component }, { it })

        val securityEntries = grouped["security"]?.toList() ?: emptyList()
        if (securityEntries.isNotEmpty()) {
            logger.info("NetonConfig: found ${securityEntries.size} security configurer(s)")
            if (moduleId != null) {
                writeToSink(securityEntries)
            } else {
                generateConfigRegistry(securityEntries)
            }
        }

        return emptyList()
    }

    /** 模块模式：写片段到 sink */
    private fun writeToSink(securityEntries: List<ConfigEntry>) {
        ModuleFragmentSink.addStat(moduleId!!, "configs", securityEntries.size)
        ModuleFragmentSink.addImports(
            moduleId!!,
            "import neton.core.config.NetonConfigurer",
            "import neton.core.config.NetonConfigRegistry",
            "import neton.core.config.NetonConfigurers",
            "import neton.core.interfaces.SecurityBuilder"
        )
        securityEntries.forEach {
            ModuleFragmentSink.addImport(moduleId, "import ${it.clazz.qualifiedName!!.asString()}")
        }

        val configurersList = securityEntries.joinToString(",\n            ") {
            "NetonConfigurers.ordered(${it.order}, ${it.clazz.simpleName.asString()}())"
        }

        // 在 initializer 内定义 configRegistry 并 bind
        val code = buildString {
            appendLine("        val configRegistry = object : NetonConfigRegistry {")
            appendLine("            override val securityConfigurers: List<NetonConfigurer<SecurityBuilder>> = listOf(")
            appendLine("                $configurersList")
            appendLine("            )")
            appendLine("        }")
            append("        ctx.bindIfAbsent(NetonConfigRegistry::class, configRegistry)")
        }

        ModuleFragmentSink.addFragment(moduleId, "configs", "注册安全配置器", code)
    }

    /** 兼容模式：生成独立文件 */
    private fun generateConfigRegistry(securityEntries: List<ConfigEntry>) {
        val file = codeGenerator.createNewFile(
            dependencies = Dependencies(true, *securityEntries.mapNotNull { it.clazz.containingFile }.toTypedArray()),
            packageName = "neton.core.generated",
            fileName = "GeneratedNetonConfigRegistry"
        )

        OutputStreamWriter(file).use { writer ->
            writer.write(
                """
                // AUTO-GENERATED - DO NOT EDIT
                // Generated by Neton KSP NetonConfigProcessor
                package neton.core.generated

                import neton.core.config.NetonConfigurer
                import neton.core.config.NetonConfigRegistry
                import neton.core.config.NetonConfigurers
                import neton.core.interfaces.SecurityBuilder

                """.trimIndent()
            )

            securityEntries.forEach { writer.write("import ${it.clazz.qualifiedName!!.asString()}\n") }

            writer.write(
                """

                object GeneratedNetonConfigRegistry : NetonConfigRegistry {

                    override val securityConfigurers: List<NetonConfigurer<SecurityBuilder>> = listOf(
                """.trimIndent()
            )

            if (securityEntries.isNotEmpty()) {
                writer.write(securityEntries.joinToString(",\n") {
                    "NetonConfigurers.ordered(${it.order}, ${it.clazz.simpleName.asString()}())"
                })
            }

            writer.write(
                """

                    )
                }
                """.trimIndent()
            )
        }
    }
}

class NetonConfigProcessorProvider : SymbolProcessorProvider {
    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {
        return NetonConfigProcessor(environment.codeGenerator, environment.logger, environment.options)
    }
}
