package neton.ksp

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import java.io.OutputStreamWriter

private val MODULE_ID_PATTERN = Regex("^[a-z][a-z0-9-]*$")

/**
 * 模块初始化器聚合处理器
 *
 * 读取 KSP 选项 `neton.moduleId`，从 ModuleFragmentSink 收集各 Processor 写入的片段，
 * 聚合生成唯一的 `{Id}ModuleInitializer` 实现 `ModuleInitializer` 接口。
 *
 * 各 Processor 在检测到 moduleId 存在时，不生成独立的 Registry/Initializer 文件，
 * 而是将注册代码片段写入 ModuleFragmentSink。本 Processor 统一输出。
 *
 * moduleId 约束：只允许 [a-z][a-z0-9-]*（小写字母开头，后续小写/数字/短横线）。
 *
 * KSP 选项配置（build.gradle.kts）：
 * ```
 * ksp { arg("neton.moduleId", "member") }
 * ```
 *
 * 若未配置 `neton.moduleId`，则不生成任何代码（保持兼容模式）。
 */
class ModuleInitializerProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger,
    private val options: Map<String, String>
) : SymbolProcessor {

    private var invoked = false

    override fun process(resolver: Resolver): List<KSAnnotated> {
        if (invoked) return emptyList()
        invoked = true

        val moduleId = options["neton.moduleId"]
        if (moduleId.isNullOrBlank()) {
            return emptyList()
        }

        // P0-2: moduleId 格式校验 fail-fast
        if (!MODULE_ID_PATTERN.matches(moduleId)) {
            logger.error(
                "neton.moduleId '$moduleId' is invalid. " +
                        "Must match [a-z][a-z0-9-]* (lowercase, start with letter, allow digits and hyphens)"
            )
            return emptyList()
        }

        if (!ModuleFragmentSink.hasFragments(moduleId)) {
            logger.info("ModuleInitializer[$moduleId]: no fragments collected, skip generation")
            return emptyList()
        }

        generateModuleInitializer(moduleId)

        // 清空该 moduleId 的 sink，避免多轮累积
        ModuleFragmentSink.clear(moduleId)

        return emptyList()
    }

    private fun generateModuleInitializer(moduleId: String) {
        val pascalId = moduleId.toPascalCase()
        val className = "${pascalId}ModuleInitializer"
        val pkg = "neton.module.$moduleId.generated"

        val fragments = ModuleFragmentSink.getFragments(moduleId)
        val imports = ModuleFragmentSink.getImports(moduleId)
        val topLevelDecls = ModuleFragmentSink.getTopLevelDeclarations(moduleId)
        val stats = ModuleFragmentSink.getStats(moduleId)

        val file = codeGenerator.createNewFile(
            dependencies = Dependencies(true),
            packageName = pkg,
            fileName = className
        )

        OutputStreamWriter(file).use { w ->
            w.write("// AUTO-GENERATED by Neton KSP ModuleInitializerProcessor - DO NOT EDIT\n")
            w.write("package $pkg\n\n")

            // imports
            w.write("import neton.core.component.NetonContext\n")
            w.write("import neton.core.module.ModuleInitializer\n")
            imports.sorted().forEach { w.write("$it\n") }
            w.write("\n")

            // 顶层声明（Validator 类等）
            topLevelDecls.forEach { decl ->
                w.write(decl)
                w.write("\n")
            }

            w.write("/**\n")
            w.write(" * 模块 [$moduleId] 的自动生成初始化器\n")
            w.write(" *\n")
            w.write(" * 聚合了本模块的全部 KSP 产物（路由、校验器、仓库、定时任务、配置器）。\n")
            w.write(" * 在 Neton.run { modules($className) } 中注册即可加载。\n")
            w.write(" */\n")
            w.write("object $className : ModuleInitializer {\n\n")
            w.write("    override val moduleId: String = \"$moduleId\"\n\n")

            // dependsOn
            val dependsOnRaw = options["neton.moduleDependsOn"]?.takeIf { it.isNotBlank() }
            if (dependsOnRaw != null) {
                val deps = dependsOnRaw.split(",").map { it.trim() }.filter { it.isNotEmpty() }
                if (deps.isNotEmpty()) {
                    val depsList = deps.joinToString(", ") { "\"$it\"" }
                    w.write("    override val dependsOn: List<String> = listOf($depsList)\n\n")
                }
            }

            if (stats.isNotEmpty()) {
                val entries = stats.entries.joinToString(", ") { "\"${it.key}\" to ${it.value}" }
                w.write("    override val stats: Map<String, Int> = mapOf($entries)\n\n")
            }
            w.write("    override fun initialize(ctx: NetonContext) {\n")

            fragments.forEach { fragment ->
                w.write("        // ${fragment.comment}\n")
                w.write(fragment.code)
                w.write("\n\n")
            }

            w.write("    }\n")
            w.write("}\n")
        }

        logger.info("Generated $pkg.$className with ${fragments.size} fragment(s)")
    }
}

/** 将 kebab-case 或 snake_case 转为 PascalCase */
private fun String.toPascalCase(): String {
    return split('-', '_', '.').joinToString("") { part ->
        part.replaceFirstChar { it.uppercaseChar() }
    }
}

class ModuleInitializerProcessorProvider : SymbolProcessorProvider {
    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {
        return ModuleInitializerProcessor(
            environment.codeGenerator,
            environment.logger,
            environment.options
        )
    }
}
